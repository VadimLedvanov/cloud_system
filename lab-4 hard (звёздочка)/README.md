Цель работы:
В работе, рассмотрим установку HashiCorp Vault, настройку аутентификации, управление доступом к секретам и использование этих секретов в Jenkins пайплайне, не отображая их в логах.
Ход работы:
Задание 1. 
Поднимаем HashiCorp Vault в в контейнере Docker:
![изображение](https://github.com/user-attachments/assets/613aa25b-8d60-4441-a890-d6a69bb6f0d8)

Далее, присваиваем Http-адрес для контейнера и открываем Vault в Chrome и авторизуемся по токену:
![изображение](https://github.com/user-attachments/assets/f0a1cfbd-785a-4a1c-a3e5-e6381849d23b)


На странице ниже выбираем метод TOKEN и вводим ‘root-token’:
![изображение](https://github.com/user-attachments/assets/5dfad5e6-1ab5-489c-95a6-affb2e6c04d6)

Далее, инициализируем Secrets Engine. Выбираем KV и вводим название:
![изображение](https://github.com/user-attachments/assets/ae8fdbe3-de1a-455d-9a78-a8db1fcf5480)

Необходимо ввести путь к секрету и его данные, в формате ключ- значение:
![изображение](https://github.com/user-attachments/assets/55fd3b95-dcf0-478e-b2da-a329d6949990)


Чтобы Jenkins мог подключаться к Vault и запрашивать секреты, нужно установить плагин HashiCorp Vault для Jenkins. Из менеджера Jenkins устанавливаем ‘HashiCorp Vault Plugin’:
![изображение](https://github.com/user-attachments/assets/73246ced-9c5c-4f10-853a-2ac06c2ce301)


После установки плагина для обеспечения их взаимодействия открываем ‘Configure System’ в менаджере. 
Необходимо добавить новую конфигурацию Jenkins для Vault. В ней указываются значения URL, Vault Token, Engine Version. Они были настроены раньше. Первичная настройка взаимодействия представлена ниже: 
 ![изображение](https://github.com/user-attachments/assets/898a4f5f-4c18-4016-b6bd-0759d47e8fba)


Чтобы Jenkins мог инициализировать обращение к хранилищу секретов, производим заполнение полей в параметре Credentials (его значение ‘-none-’) на рисунке выше. 
Указаны параметры, соответсвующие текущей настройке и сервисам на каждом Localhost:
•	Username: ‘root’ (оно уже создано в в HashiCorp Vault)
•	в поле Password: ‘root-token’ - токен доступа, созданный для Jenkins.
•	ID: явно указываем уникальную строку – “ vault-access-credentials ”
Описанные параметры применяются к Jenkins на скриншоте ниже:
![изображение](https://github.com/user-attachments/assets/097ab0cb-5767-4f6c-a5f3-e735883f484e)


После заполнения всех полей нажмите OK для сохранения учетных данных.


Переходим к практическим запускам пайплайна из более ранней работы. В последний Stage был добавлен блок ‘withVault(’. В нем добавлена опция “credentialsId: ' access-credential’ ”, где ‘access-credential’ — это ID учетных данных, которые были создали для Vault.
Полный код пайплайна:
![изображение](https://github.com/user-attachments/assets/2925c132-47d9-44f9-b845-9133d1afd7d2)


Jenkins, по задумке и документации, должен получить секрет из Vault, не выводя его в логах.

На практике получаем ошибку в этом Stage:
![изображение](https://github.com/user-attachments/assets/de0dab6d-ce57-45a9-8a88-8c06146a000e)


Происходит это вследствие особенностей взаимодействия HashiCorp Vault и Jenkins в контейнеризированной среде Docker:
1)	Jenkins, работающий в Linux, не может получить к нему прямой доступ. Если сеть Docker Vault настроена неправильно, Jenkins в Linux не сможет отправлять запросы в Vault, используя локальный хост или обычные порты.
2)	Jenkins не может отправлять запросы к Vault через localhost или нестандартные замапленные порты.
3)	Даже если Jenkins сможет подключиться к контейнеру Vault, существует проблема с защитой и сохранением конфиденциальных данных. Это может привести к тому, что личная информация будет сохранена в журналах или местах, доступных из среды пайплайна Jenkins.
4)	Эта конфигурация не подходит для сред с использованием секретов, поскольку в ней не используются токены или другие методы аутентификации, необходимые подключаемому модулю Jenkins Vault. Тогда он не будет иметь адекватной безопасности и защиты секрета

В заключении я приведу несколько доводов, Почему это решение не починить:
•	пайплайн Jenkins не сможет подключиться к Vault должным образом: HashiCorp Vault работает в контейнере Docker на доп. Localhost, а Jenkins — как приложение на Linux.
•	Vault и Jenkins в данной системе не имеют защищенного соединения и безопасного метода аутентификации
Задание 2. 

Причины, по которой этот способ (HashiCorp Vault работает в контейнере Docker на доп. Localhost, а Jenkins — как приложение на Linux.) – красивый:
1)	Контроль доступа к секретам со стороны HashiCorp Vault
2)	Когда мы запускаете Vault в контейнере Docker, это создаёт дополнительную защиту. Vault работает сам по себе и управляется Docker-сетью. Это значит, что другие программы не могут легко получить доступ к Vault.

3)	Docker позволяет применять настройки сети по средствам маппинга портов, ограничивая доступ к Vault. 
4)	Vault может создавать временные токены или учётные данные, которые истекают со временем или отключаются: Это снижает риск несанкционированного доступа

В заключении,
Ниже приведены причины, по которым хранение секретов в CI/CD-переменных репозитория — плохая практика:
Хранение секретов (паролей, токенов) в переменных CI/CD-пайплайна связано с рисками. Они могут попасть в логи, где их увидят все, у кого есть доступ к системе CI/CD. Кроме того, изменить такие секреты вручную сложно, а встроенных инструментов для контроля доступа, ротации и мониторинга нет, что усложняет управление безопасностью. Вследствие этого нужно усложнять систему дополнительными надстройками. 

Вывод:
Таким образом, Vault в Docker позволяет создать надёжную систему управления секретами, в то время как хранение их в CI/CD-переменных — менее безопасная практика, которая может привести к утечке конфиденциальных данных и усложнить управление доступом.
