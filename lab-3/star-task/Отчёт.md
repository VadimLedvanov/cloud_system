# Задача
- Создать helm chart на основе обычной 3 лабы
- Задеплоить его в кластер
- Поменять что-то в сервисе, задеплоить новую версию при помощи апгрейда релиза
- В отчете приложить скрины всего процесса, все использованные файлы, а также привести три причины, по которым использовать хелм удобнее чем классический деплой через кубернетес манифесты


# Ход работы
## Создание структуры Helm Chart
Был установлен Helm, после чего был создан новый Helm chart [image1](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image1.png) при помощи следующей команды:
```
helm create simple-service
```
В созданной директории в процессе переноса логики из k8s.yaml (обычной 3 лабы) в Helm-чарты были выполнены следующие изменения:
  1. Файл templates/deployment.yaml: В файле было создано описание Deployment, использующее шаблонизацию Helm. Поля name, app, и image были параметризованы, чтобы подставлять значения из Helm-атрибутов, таких как .Release.Name для названия и .Values.image.repository и .Values.image.tag для образа. Это позволяет гибко задавать имя деплоя и версию контейнерного образа через значения в values.yaml.

  2. Файл templates/service.yaml: В файле было создано описание Service типа NodePort. Название сервиса и селекторы также были параметризованы с использованием .Release.Name. Порт nodePort для внешнего доступа был вынесен в values.yaml и стал настраиваемым через .Values.service.nodePort, что позволяет легко изменять его при необходимости.

  3. Файл values.yaml: В этот файл были добавлены параметры для настройки образа и порта. Поля image.repository и image.tag позволяют задавать название репозитория и тег образа контейнера, что упрощает управление версиями. Также было добавлено поле service.nodePort, задающее внешний порт, к которому привязывается сервис. Изначально в tag была задана исходная версия - latest [first-image-verion](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/valuesYamlImageИсходный.png).

## Деплой Helm chart в кластер

Созданный Helm chart был установлен в кластер [image1](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image1.png) при помощи следующей команды:
```
helm install simple-service ./simple-service
```
Эта команда создала release с именем simple-service и применила все манифесты. Для проверки создданного кластера [image1](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image1.png) была запущена команда:
```
kubectl get services
```
После чего в миникуб была произведена проверка работы исходной версии сервиса [image2](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image2.png)

## Изменение сервиса, обновление докер образа и деплой при помощи апгрейда релиза
В файле сервера был изменен текст "Hello world" на "Hello from new updated version" после чего был обновлён созданный ранее Docker-образ под версией "new-version" [image3](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image3.png).
Далее в файле values.yaml было обновлено значение тега образа контейнера. Поле image.tag изменено с "latest" на "new-version" [last-image-verion](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/valuesYamlImageНовый.png), что указывает Helm использовать новый образ для деплоя.

После этого была выполнена команда обновления [image4](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image4.png):
```
helm upgrade simple-service ./simple-service
```
Команда helm upgrade обновляет существующий релиз simple-service с учетом изменений в чарте и values.yaml. 

После чего в миникуб была произведена проверка работы новой версии сервиса [image5](https://github.com/VadimLedvanov/cloud_system/blob/main/lab-3/star-task/image5.png). При этом поды не обновились, для чего были принудительно удалены старые поды, после чего они пересоздались с новым образом:

# Причины, по которым использовать Helm удобнее, чем классический деплой через Kubernetes манифесты
1. **Упрощение управления версиями.**
С Helm можно легко управлять разными версиями приложений, обновлять их и возвращаться на предыдущие версии в случае необходимости.
2. **Использование параметров и шаблонов.**
Helm Charts поддерживают использование переменных и шаблонов, что позволяет легко изменять конфигурации для различных окружений (например, продакшен, тест) без необходимости редактировать множество манифестов вручную.
3. **Пакетный подход к деплою.**
с помощью Helm можно управлять комплексными приложениями, которые состоят из нескольких сервисов, секретов, конфигмапов и других ресурсов, как одним пакетом. Это делает процесс деплоя и управления зависимостями более структурированным и предсказуемым.

